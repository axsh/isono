# -*- coding: utf-8 -*-

require 'thread'
require 'ostruct'

module Isono
  module NodeModules
    class RpcChannel < Base
      include Logger

      class RpcError < RuntimeError; end
      class UnknownEndpointError < RpcError; end
      class DuplicateEndpointError < RpcError; end

      config_section do
        desc "default timeout duration in second until receive response."
        timeout_sec (60*3).to_f
        desc "Prefetch size for receiver queue channel"
        receiver_prefetch_size 10
      end

      initialize_hook do
        @active_requests = {}
        @stats = {
          :total_request_count=>0,
          :total_response_count=>0,
          :peak_wait_response_size=>0,
          :send_request_per_sec=>0,
          :receive_response_per_sec=>0,
          :per_sec_last_request_count=>0,
          :per_sec_last_response_count=>0,
        }
        @endpoints = {}
        @amq = node.create_channel
        @amq.prefetch(config_section.receiver_prefetch_size.to_i)
        @amq.queue("command-recv.#{manifest.node_id}", {:exclusive=>true}).subscribe(:ack=>true) { |header, data|
          header.ack
          @stats[:total_response_count] += 1
          req = @active_requests[header.message_id]
          if req
            data = Serializer.instance.unmarshal(data)
            req.process_event(:on_received, data)
            begin
              case data[:type]
              when :inprogress
                req.progress_cb.call(data[:msg]) if req.progress_cb
              when :error
                req.process_event(:on_error, data)
                req.error_cb.call(data[:msg]) if req.error_cb
              else
                req.process_event(:on_success, data)
                req.success_cb.call(data[:msg]) if req.success_cb
              end
            rescue => e
              logger.error(e)
            ensure
              if req.state == :done
                @active_requests.delete req.ticket
              end
            end
          end
        }

        # Cleanup timed out requests
        EventMachine.add_periodic_timer(10) {
          tnow = Time.now
          @active_requests.each { |k,req|
            next unless req.state == :waiting
            if req.timeout_sec.to_f > 0.0 && req.timeout_sec.to_f > (tnow - req.sent_at)
              @active_requests.delete(k)
              req.error_cb.call(:timeout) if req.error_cb
            end
          }
        }

        # Update stats
        EventMachine.add_periodic_timer(5) {
          @stats[:send_request_per_sec] = (@stats[:total_request_count] - @stats[:per_sec_last_request_count]) / 5
          @stats[:per_sec_last_request_count] = @stats[:total_request_count]
          @stats[:receive_response_per_sec] = (@stats[:total_response_count] - @stats[:per_sec_last_response_count]) / 5
          @stats[:per_sec_last_response_count] = @stats[:total_response_count]
        }

        # RPC endpoint for statistics info of this node.
        myinstance.register_endpoint("rpc-stats.#{manifest.node_id}", proc { |req, res|
                                       case req.command
                                       when 'get'
                                         res.response({:active_requests => @active_requests.map {|a| a.hash },
                                                        :endpoints => @endpoints.keys
                                                      })
                                       else
                                         raise Rack::UnknownMethodError
                                       end
                                     })
      end

      terminate_hook do
        @endpoints.keys.each { |ns|
          myinstance.unregister_endpoint(ns)
        }
        @amq.queue("command-recv.#{manifest.node_id}", {:exclusive=>true}).delete
      end

      attr_reader :amq

      # Make a RPC request to an endpoint.
      # 
      # @param [String] endpoint
      # @param [String] command
      # @param [Array] args
      # @param [Proc] &blk Block to setup the request context.
      # @return [RequestContext,any]
      #
      # @example create a sync RPC request.
      #   rpc.request('endpoint1', 'func1', xxxx)
      # @example call RPC in async mode.
      #   rpc.request('endpoint1', 'func1', xxxx) { |req|
      #     req.on_success { |r|
      #       puts r
      #     }
      #     req.on_error { |r|
      #       puts r
      #     }
      #   }
      #
      # @example setup request context and do wait().
      #   Note that callbacks are 
      #   rpc.request('endpoint1', 'func1', xxxx) { |req|
      #     # send new attribute
      #     req.request[:xxxx] = "sdfsdf"
      #     # returns synchronized RequestContext to block caller.
      #     req.synchronize
      #   }.wait # request() get back the altered RequestCotenxt that has wait().
      #
      # @example Create async oneshot call. (do not expect response) 
      #   rpc.request('endpoint1', 'func1') { |req|
      #     req.oneshot = true
      #   }
      def request(endpoint, command, *args, &blk)
        req = RequestContext.new(endpoint, command, args)
        # the block is to setup the request context prior to sending.
        if blk
          # async 
          r = blk.call(req)
          req = r if r.is_a?(RequestContext)
          send_request(req)
          req
        else
          # sync
          req = req.synchronize
          send_request(req)
          req.wait
        end
      end

      # Register a new RPC endpoint.
      #
      # This method works in sync mode if called at non-EM reactor thread.
      # @param [String] endpoint
      # @param [has call() method]  app
      # @param [Hash] opts
      #    :exclusive
      #    :prefetch
      def register_endpoint(endpoint, app, opts={})
        raise TypeError unless app.respond_to?(:call)
        opts = {:exclusive=>true, :prefetch=>0}.merge(opts)
        
        # create receive queue for new RPC endpoint.
        endpoint_proc = proc { |header, data|

          data = Serializer.instance.unmarshal(data)

          resctx = if data[:oneshot]
                     OneshotResponseContext.new(@endpoints[endpoint][:ch].response_exchange, header)
                   else
                     ResponseContext.new(@endpoints[endpoint][:ch].response_exchange, header)
                   end
          begin
            req = Rack::Request.new({:sender=>header.reply_to['command-recv.'.size..-1],
                                      :message_id=>header.message_id
                                    }.merge(data))
            res = Rack::Response.new(resctx)
            ret = app.call(req, res)
          rescue ::Exception => e
            logger.error(e)
            resctx.response(e) unless resctx.responded?
          end
        }

        
        EventMachine.schedule {
          ch = if opts[:prefetch].to_i > 0
                 # create per endpoint channel
                 node.create_channel
               else
                 # use default channel
                 @amq
               end
          ch.instance_eval %Q{
            def endpoint_queue
              self.queue("isono.rpc.endpoint.#{endpoint}", {:exclusive=>false, :auto_delete=>true})
            end

            def response_exchange
              self.default_exchange
            end
          }
          ch.prefetch(opts[:prefetch].to_i) if opts[:prefetch].to_i > 0
          # stores hash here that is for thread safety.
          @endpoints[endpoint]={:app=>app, :opts=>opts, :ch=>ch}

          ch.endpoint_queue.subscribe(:ack=>true, &endpoint_proc)
          event.publish('rpc/register', :args=>[endpoint])
        }
      end

      # Unregister endpoint.
      # 
      # @param [String] endpoint endpoint name to be removed
      def unregister_endpoint(endpoint)
        if @endpoints.has_key?(endpoint)
          EventMachine.schedule {
            data = @endpoints.delete(endpoint)
            # endpoint_queue is :auto_delete=>true so that it will be deleted
            # in case of zero consumers.
            data[:ch].endpoint_queue.unsubscribe
            event.publish('rpc/unregister', :args=>[endpoint])
          }
        end
      end
      
      private
      def endpoint_queue_name(ns)
        "isono.rpc.endpoint.#{ns}"
      end

      def event
        @event ||= EventChannel.new(node)
      end

      # Publish a RPC request asynchronously.
      # @param [RequestContext] req Request context object to be
      # sent. If the context's state is not :init, it will fail.
      def send_request(req)
        raise TypeError if !req.is_a?(RequestContext)
        raise "Request context seems to be sent already: #{req.state}" if req.state != :init

        # possible timeout_sec values:
        # timeout_sec == -1.0 : to be overwritten to the default timeout.
        # timeout_sec == 0.0  : never be timed out.
        # timeout_sec > 0.0   : wait for the user set timeout.
        if req.timeout_sec == -1.0
          # set default timeout if no one updated the initial value.
          req.timeout_sec = config_section.timeout_sec
        end
                
        req.process_event(:on_ready)
        
        EventMachine.schedule {
          @stats[:total_request_count] += 1
          if @stats[:peak_wait_response_size] < @active_requests.size
            @stats[:peak_wait_response_size] = @active_requests.size
          end
          if !req.oneshot
            @active_requests[req.ticket] = req
          end

          amq.default_exchange.publish(Serializer.instance.marshal(req.request_hash),
                                       {:message_id => req.ticket,
                                         :key => endpoint_queue_name(req.endpoint),
                                         :reply_to=>"command-recv.#{manifest.node_id}"}
                                       )
          req.process_event(:on_sent)
        }
      end

      class ResponseContext
        attr_reader :header
        
        def initialize(exchange, header)
          @responded = false
          @exchange = exchange
          @header = header
        end

        def responded?
          @responded
        end

        def progress(ret)
          EM.schedule {
            publish(:inprogress, ret)
          }
        end

        def response(ret)
          raise "" if @responded

          EM.schedule {
            @header.ack
            if ret.is_a? Exception
              publish(:error, {:message=> ret.message, :error_type => ret.class.to_s})
            else
              publish(:success, ret)
            end
          }
          @responded = true
        end

        private
        def publish(type, body)
          @exchange.publish(Serializer.instance.marshal({:type=>type, :msg=>body}),
                                       {:key=>@header.reply_to,
                                         :message_id=>@header.message_id}
                                       )
        end
      end

      # Do nothing when the endpoint trys to send back in case of
      # oneshot request.
      class OneshotResponseContext < ResponseContext
        def progress(ret)
        end

        def response(ret)
          raise "" if @responded

          EM.schedule {
            @header.ack
          }
          @responded = true
        end
      end

      class RequestContext < OpenStruct
        # They are not to be appeared in @table so that won't be inspect().
        attr_reader :error_cb, :success_cb, :progress_cb
        attr_reader :state

        def initialize(endpoint, command, args)
          super({:request=>{
                    :endpoint=> endpoint,
                    :command => command,
                    :args => args
                  },
                  :ticket => Util.gen_id,
                  :timeout_sec => -1.0,
                  :oneshot => false,
                  :sent_at => nil,
                  :completed_at => nil,
                  :complete_status => nil,
                })
          
          @success_cb = nil
          @progress_cb = nil
          @error_cb = nil

          @state = :init
        end

        def endpoint
          self.request[:endpoint]
        end

        def command
          self.request[:command]
        end

        def process_event(ev, *args)
          case [ev, @state]
          when [:on_ready, :init]
            @state = :ready
          when [:on_sent, :ready]
            @state = :waiting
            self.sent_at=Time.now
            # freeze request hash not to be modified after sending.
            self.request.freeze
          when [:on_received, :waiting]
            @state = :waiting
          when [:on_success, :waiting]
            @state = :done
            self.completed_at=Time.now
            self.complete_status = :success
          when [:on_error, :waiting]
            @state = :done
            self.completed_at=Time.now
            self.complete_status = :fail
          else
            raise "Unknown state transition: #{ev}, #{@state}"
          end
        end

        def elapsed_time
          self.completed_at.nil? ? nil : (self.completed_at - self.sent_at)
        end

        def hash
          # state, sent_at received_at are readonly values so they are
          # not pushed in @table.
          @table.dup.merge({:state=>self.state})
        end

        def request_hash
          request.merge({:oneshot=>oneshot})
        end

        def on_success(&blk)
          raise ArgumentError unless blk
          @success_cb = blk
        end

        def on_progress(&blk)
          raise ArgumentError unless blk
          @progress_cb = blk
        end

        def on_error(&blk)
          raise ArgumentError unless blk
          @error_cb = blk
        end

        def synchronize
          self.extend RequestSynchronize
          self
        end

        module RequestSynchronize
          def self.extended(mod)
            raise TypeError, "This module is applicable only for RequestContext" unless mod.is_a?(RequestContext)
            # overwrite callbacks
            mod.instance_eval {
              @q = ::Queue.new
              
              on_success { |r|
                @q << [:success, r]
              }
              on_error { |r|
                @q << [:error, r]
              }
            }
          end

          public
          def wait()
            raise "response was received already." if state == :done
            raise "wait() has to be called at outside of the EventMachine's main loop." if EventMachine.reactor_thread?
            
            r = @q.deq
            
            case r[0]
            when :success
              r[1]
            when :error
              raise RpcError, r[1]
            end
          end
        end
        
      end
      
    end
  end
end
