# -*- coding: utf-8 -*-

module Isono
  module NodeModules
    class NodeCollector < Base
      include Logger

      config_section do
        desc "time in second to recognize if the agent is timed out"
        timeout_sec (10*2).to_f
        desc "time in second to recognize if the agent is offline"
        offline_sec (10*2*2).to_f
        desc "the agent to be killed from the datasource after the time of second"
        kill_sec (10*2*2*8).to_f
        desc ""
        gc_period 20.0
      end

      initialize_hook do
        # GC event trigger for agent timer & status
        @gc_timer = EM::PeriodicTimer.new(config_section.gc_period) {
          event = EventChannel.new(self.node)
          DataStore.pass {
            # Sqlite3 is unlikely to modify table while iterating
            # the result set. the following is the case of the
            # iteration for the opened result set.
            # Models::AgentPool.dataset.each { |row|
            # 
            # while Model.dataset.all, it returns a Ruby array
            # containing rows so that i had no table lock exception.
            # see:
            # http://www.mail-archive.com/sqlite-users@sqlite.org/msg03328.html
            # TODO: paging support for the large result set.
            Models::NodeState.dataset.all.each { |row|
              diff_time = Time.now - row[:last_ping_at]
              if row.state != "timeout" && row.state != "offline" && diff_time > config_section.timeout_sec
                row.process_event(:on_timeout)
                row.save_changes
                event.publish('node_collector/timedout', :args=>[row.values])
              end

              if row.state != "offline" && diff_time > config_section.offline_sec
                row.process_event(:on_unmonitor)
                row.save_changes
                event.publish('node_collector/offline', :args=>[row.values])
              end

              if diff_time > config_section.kill_sec
                event.publish('node_collector/killed', :args=>[row.values])
                row.destroy
              end
            }
          }
        }

        rpc = RpcChannel.new(node)
        app = Rack::ObjectMethod.new(myinstance)
        rpc.register_endpoint('node-collector', Rack.build do
                                use Rack::DataStore
                                run app
                              end)
      end
      
      terminate_hook do
        @gc_timer.cancel
      end

      def list
        Models::NodeState.dataset.all.map{|r| r.values }
      end

      def notify(node_id, boot_token)
        event = EventChannel.new(node)
        
        a = Models::NodeState.find(:node_id=>node_id) || Models::NodeState.new(:node_id=>node_id)
        a.process_event(:on_ping)
        if a.new?
          a.boot_token = boot_token
          a.save
          event.publish('node_collector/monitored', :args=>[a.values])
        else
          a.save_changes
          #event.publish('node_collector/pong')
        end
      end

    end
  end
end
